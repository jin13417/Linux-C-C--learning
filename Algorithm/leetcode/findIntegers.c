/*************************************************************************
 > File Name: findIntegers.c
 > Author:  jinshaohui
 > Mail:    jinshaohui789@163.com
 > Time:    18-09-09
 > Desc:  不含连续1的非负整数
 ************************************************************************/
#include<stdio.h>

/*
题目:
	给定一个正整数 n，找出小于或等于 n 的非负整数中，
              其二进制表示不包含 连续的1 的个数。   

 如果n=2^k - 1，其中k为正整数，那么问题就变成二进制数
 00……0（k个0）到11……1（k个1）中有几个数不包含连续
 的1，设答案为f(k)。

我们可以考虑k位二进制数的第一位：如果第一位是0，那
么第二位既可以取0也可以取1，也就是说对后面的k-1位无
影响，所以第一位为0的满足条件的数总共有f(k-1)个；如果
第一位是1，那么由于不能出现连续的1，第二位只能取0，
但是对后面的k-2位无影响，所以第一位为1的满足条件的数
总共有f(k-2)个。

这样，我们就得到了：f(k) = f(k-1) + f(k-2)。边界条件为f(1)=2以及f(2)=3，
由于f(0)=1满足原问题的题意也满足上述的转移方程，故可以取边界条件f(0)=1，f(1)=2。
*/
int findIntegers(int num)
{
	int dp[32] = {0};
	int i = 0;
	int res = 0;
	int preBit = 0;
	int k = 31;

	dp[0] = 1; /*bit 1 个数*/
	dp[1] = 2; 

	for (i = 2; i < 32; i ++)
	{
		dp[i] = dp[i - 1] + dp[i - 2];
	}

	while(k >= 0)
	{
		if(num & (1 << k))
		{
			res += dp[k];
			if(preBit)
			{
				return res;
			}
			preBit = 1;
		}
		else
		{
			preBit = 0;
		}
		k--;
	}

	return res + 1;
}

int main()
{
	int i = 0;

	for (i = 0; i < 20; i++)
	{
		printf("\r\n num %d = %d",i ,findIntegers(i));
	}

	return 0;
}
